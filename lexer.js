;const print = console.log;const std_plus = (a, b) => a + b; /* todo make N-ary */const std_minus = (a, b) => a - b;const std_times = (a, b) => a * b;const std_div = (a,b) => a / b;const std_mod = (a, b) => a % b;const std_if = (cond, a, b) => cond ? a : b;const std_true = true;const std_false = false;const std_concat = (a,b) =>  {     let x = [];    x = x.concat(a);    x = x.concat(b);    return x;}; /* TODO work for N-ary */const eq = (a, b) => a === b;const not = (a) => !a;const js = (a) => eval(a);/* these builtins are implemented in JS for performance (mainly for non-recursive options) */const builtin_loop = (start, end, f) => {    for(let i = start; i < end; i++) f(i);};const range = (start, end) => {    let list = [];    for(let i = start; i < end; i++) list += i;    return list;};/*takes in: $0 a list          $1 a function, that, for each element, takes in:              $0 - element              $1 - the index              $2 - the original $0 list          and returns the new value to use */const map = (list, f) => {    return list.map(f)};/* same as map, but f should return a boolean *//* if it's true, the element is kept in the list, otherwise discarded */const select = (list, f) => {     return list.filter(f)};/* if list is [1, 2, 3, 6] *//* returns f(f(f(1, 2), 3), 6) */const reduceNonEmpty = (list, f) => {    let e = list[0];    for(let i = 1; i < list.length; i++) {        e = f(e, list[i]);    }    return e;};const reduceWithStarter = (list, starter, f) => {    let e = starter;    for(let i = 0; i < list.length; i++) {        e = f(e, list[i])    }    return e;};/* reads the file. Assumes utf8 */const readFile = (filename) => {    return require('fs').readFileSync(filename, 'utf8')};const length = (x) => x.length;const get = (a, b) => a[b];const indexOf = (str, item, startingIndex) => str.indexOf(item, startingIndex);const substring = (str, start, end) => str.substring(start, end);const slice = (array, start, end) => array.slice(start, end);/* this calls 'f' with 'arr' as the argument array*//* call { $N } (list 1 2 3) => (list 1 2 3) */const call = (f, arr) => {    return f(...arr);};/* $0 the input string$1 the function to determine if a chars' index should be used$2 the value to return in the event that none match */const indexOfFirstOrElse = (str, f, value) => {    for(let i = 0; i < str.length; i++) {        if(f(str[i])) return i;    }    return value;};const CHARS_hash = '#';const CHARS_newline = '\n';const CHARS_quote = '"';;;
;;(((...arr) => { const filename = js("process.argv[2]");const preprocess = ((...arr) => { const loopIntrinsic = (...arr) => { const start = (arr[0]);const end = (arr[1]);const f = (arr[2]);f(start);const newStart = std_plus(start,1);return std_if(eq(newStart,end),(...arr) => { },(...arr) => { return loop(newStart,end,f)})()};const loop = builtin_loop;const loopTilValue = (...arr) => { const startingValue = (arr[0]);const iteratorF = (arr[1]);const bodyF = (arr[2]);const result = bodyF(startingValue);return std_if(eq(result,null),(...arr) => { return loopTilValue(iteratorF(startingValue),iteratorF,bodyF)},(...arr) => { return result})()};const infx = (...arr) => { return (arr[1])((arr[0]),(arr[2]))};const list = (...arr) => { return arr};const split_string = (...arr) => { const input = (arr[0]);const delim = (arr[1]);const length = std_if(eq(null,(arr[2])),js("Number.MAX_SAFE_INTEGER"),(arr[2]));const ret = std_if(infx(length,eq,0),(...arr) => { return list(input)},(...arr) => { const index = indexOf(input,delim);return std_if(infx(index,eq,-1),(...arr) => { return list(input)},(...arr) => { const part = substring(input,0,index);const rest = substring(input,infx(index,std_plus,1));return std_concat(list(part),split_string(rest,delim,infx(length,std_minus,1)))})()})();return ret};const preprocess = (...arr) => { const filename = (arr[0]);const ret = map(split_string(readFile(filename),CHARS_newline,null),(...arr) => { const fullLine = (arr[0]);return std_if(eq(indexOf(fullLine,CHARS_hash),-1),(...arr) => { return fullLine},(...arr) => { const splitLine = split_string(fullLine,CHARS_hash,1);const line = infx(splitLine,get,0);const comment = infx(splitLine,get,1);return std_if(eq(substring(comment,0,length("include")),"include"),(...arr) => { const filename = substring(comment,length("include "));return preprocess(filename)},(...arr) => { return line})()})()});return reduceWithStarter(ret,"",(...arr) => { return std_plus((arr[0]),std_plus(CHARS_newline,(arr[1])))})};return preprocess})();const lex = ((...arr) => { const loopIntrinsic = (...arr) => { const start = (arr[0]);const end = (arr[1]);const f = (arr[2]);f(start);const newStart = std_plus(start,1);return std_if(eq(newStart,end),(...arr) => { },(...arr) => { return loop(newStart,end,f)})()};const loop = builtin_loop;const loopTilValue = (...arr) => { const startingValue = (arr[0]);const iteratorF = (arr[1]);const bodyF = (arr[2]);const result = bodyF(startingValue);return std_if(eq(result,null),(...arr) => { return loopTilValue(iteratorF(startingValue),iteratorF,bodyF)},(...arr) => { return result})()};const infx = (...arr) => { return (arr[1])((arr[0]),(arr[2]))};const list = (...arr) => { return arr};const split_string = (...arr) => { const input = (arr[0]);const delim = (arr[1]);const length = std_if(eq(null,(arr[2])),js("Number.MAX_SAFE_INTEGER"),(arr[2]));const ret = std_if(infx(length,eq,0),(...arr) => { return list(input)},(...arr) => { const index = indexOf(input,delim);return std_if(infx(index,eq,-1),(...arr) => { return list(input)},(...arr) => { const part = substring(input,0,index);const rest = substring(input,infx(index,std_plus,1));return std_concat(list(part),split_string(rest,delim,infx(length,std_minus,1)))})()})();return ret};const input = "abc ABC a1 B1 a753+- - -7 ===";const when = (...arr) => { const value = (arr[0]);const conditional = (arr[1]);const resultIfConditionalValue = (arr[2]);const allArgs = arr;return std_if(conditional(value),(...arr) => { return resultIfConditionalValue},(...arr) => { const arguments = std_concat(list(value),slice(allArgs,3));return call(when,arguments)})()};const includedIn = (...arr) => { return not(eq(indexOf((arr[0]),(arr[1])),std_minus(0,1)))};const letters = "abcdefghijklmnopqrstuvwxyz";const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";const numbers = "0123456789";const identifierStarterCharset = std_plus(std_plus(letters,uppercase),"+-/\\<>.,%q=_$$$");const identifierBodyCharset = std_plus(std_plus(identifierStarterCharset,"!?$"),numbers);const lex = (...arr) => { const input = (arr[0]);return std_if(eq(input,""),(...arr) => { return list()},(...arr) => { const first = substring(input,0,1);const rest = substring(input,1);return when(first,(...arr) => { return eq((arr[0])," ")},(...arr) => { return lex(rest)},(...arr) => { return eq((arr[0]),CHARS_newline)},(...arr) => { return lex(rest)},(...arr) => { return eq((arr[0]),"\t")},(...arr) => { return lex(rest)},(...arr) => { return eq((arr[0]),"(")},(...arr) => { return std_concat(list(list("LPAREN","(")),lex(rest))},(...arr) => { return eq((arr[0]),")")},(...arr) => { return std_concat(list(list("RPAREN",")")),lex(rest))},(...arr) => { return eq((arr[0]),"{")},(...arr) => { return std_concat(list(list("LBRACE","{")),lex(rest))},(...arr) => { return eq((arr[0]),"}")},(...arr) => { return std_concat(list(list("RBRACE","}")),lex(rest))},(...arr) => { return eq((arr[0]),";")},(...arr) => { return std_concat(list(list("SEMICOLON",";")),lex(rest))},(...arr) => { return eq((arr[0]),"!")},(...arr) => { return std_concat(list(list("EXCLAMATION_MARK","!")),lex(rest))},(...arr) => { return eq((arr[0]),"?")},(...arr) => { return std_concat(list(list("QUESTION_MARK","?")),lex(rest))},(...arr) => { return includedIn(numbers,(arr[0]))},(...arr) => { const x = indexOfFirstOrElse(rest,(...arr) => { return not(includedIn(numbers,(arr[0])))},length(rest));const int = std_plus(std_plus("",first),substring(rest,0,x));return std_concat(list(list("INTEGER_LITERAL",int)),lex(substring(rest,x)))},(...arr) => { return includedIn(identifierStarterCharset,(arr[0]))},(...arr) => { const x = indexOfFirstOrElse(rest,(...arr) => { return not(includedIn(identifierBodyCharset,(arr[0])))},length(rest));const ident = std_plus(std_plus("",first),substring(rest,0,x));return std_concat(list(list("IDENTIFIER",ident)),lex(substring(rest,x)))},(...arr) => { return eq((arr[0]),CHARS_quote)},(...arr) => { const x = indexOfFirstOrElse(rest,(...arr) => { return eq(CHARS_quote,(arr[0]))},length(rest));const stringValue = substring(rest,0,x);return std_concat(list(list("STRING_LITERAL",stringValue)),lex(substring(rest,std_plus(x,1))))},(...arr) => { return std_true},(...arr) => { return list(list("ERROR!!!!! UNKNOWN",std_plus(first,rest)))})()})()};return lex})();return print(lex(preprocess(filename)))})());
